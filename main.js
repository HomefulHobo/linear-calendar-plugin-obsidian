/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinearCalendarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/CalendarView.ts
var import_obsidian = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  currentYear: (/* @__PURE__ */ new Date()).getFullYear(),
  dailyNoteFormat: "YYYY-MM-DD",
  dailyNoteFolderMode: "obsidian",
  dailyNoteCustomFolder: "",
  showDailyNotesInCells: false,
  // Don't show daily notes as cells by default
  showNotesWithDateAndText: true,
  // Show notes with date + text by default
  hideDateInTitle: false,
  // Show full title by default
  calendarWidth: "fit-screen",
  // Fit to screen width by default
  cellMinWidth: 30,
  // Minimum 30px per cell when scrollable
  dateExtraction: {
    startFromProperties: ["date"],
    startFromFilename: false,
    startPriority: "property",
    endFromProperties: [],
    endFromFilename: false,
    endPriority: "property"
  },
  filterMode: "none",
  filterConditions: [],
  experimental: {
    multilineNotes: false,
    verticalText: false,
    compactFontSize: false,
    condensedLetters: false
  }
};
var VIEW_TYPE_CALENDAR = "linear-calendar-view";

// src/CalendarView.ts
var LinearCalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.resizeObserver = null;
    this.tooltip = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CALENDAR;
  }
  getDisplayText() {
    return "Linear Calendar";
  }
  getIcon() {
    return "calendar";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("linear-calendar-container");
    await this.renderCalendar(container);
    this.resizeObserver = new ResizeObserver(() => {
      this.updateMultiDayBarWidths(container);
    });
    this.resizeObserver.observe(container);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf && leaf.view === this) {
          this.reload();
        }
      })
    );
  }
  async reload() {
    const container = this.containerEl.children[1];
    if (container) {
      container.empty();
      await this.renderCalendar(container);
    }
  }
  updateMultiDayBarWidths(container) {
    const bars = container.querySelectorAll(".multi-day-bar[data-span]");
    bars.forEach((bar) => {
      const span = parseInt(bar.dataset.span || "0");
      const parentCell = bar.parentElement;
      if (parentCell && parentCell.parentElement) {
        const row = parentCell.parentElement;
        const cells = Array.from(row.querySelectorAll(".day-cell"));
        const startIndex = cells.indexOf(parentCell);
        if (startIndex >= 0 && startIndex + span - 1 < cells.length) {
          const lastCell = cells[startIndex + span - 1];
          const firstCellRect = parentCell.getBoundingClientRect();
          const lastCellRect = lastCell.getBoundingClientRect();
          const totalWidth = lastCellRect.right - firstCellRect.left - 6;
          bar.style.width = `${totalWidth}px`;
        }
      }
    });
  }
  async renderCalendar(container) {
    const year = this.plugin.settings.currentYear;
    const header = container.createDiv({ cls: "calendar-header" });
    const prevBtn = header.createEl("button", { text: "\u2190", cls: "year-nav-btn" });
    header.createEl("span", { text: `${year}`, cls: "year-title" });
    const nextBtn = header.createEl("button", { text: "\u2192", cls: "year-nav-btn" });
    prevBtn.onclick = async () => {
      this.plugin.settings.currentYear--;
      await this.plugin.saveSettings();
      container.empty();
      await this.renderCalendar(container);
    };
    nextBtn.onclick = async () => {
      this.plugin.settings.currentYear++;
      await this.plugin.saveSettings();
      container.empty();
      await this.renderCalendar(container);
    };
    const notesWithDates = await this.getNotesWithDates();
    const multiDayEntries = this.processMultiDayEntries(notesWithDates);
    const calendarWrapper = container.createDiv({ cls: "calendar-wrapper" });
    const exp = this.plugin.settings.experimental;
    if (exp.multilineNotes) {
      calendarWrapper.addClass("exp-multiline");
    }
    if (exp.verticalText) {
      calendarWrapper.addClass("exp-vertical");
    }
    if (exp.compactFontSize) {
      calendarWrapper.addClass("exp-compact");
    }
    if (exp.condensedLetters) {
      calendarWrapper.addClass("exp-condensed");
    }
    if (this.plugin.settings.calendarWidth === "scrollable") {
      calendarWrapper.addClass("calendar-scrollable");
      calendarWrapper.style.overflowX = "auto";
    } else {
      calendarWrapper.removeClass("calendar-scrollable");
      calendarWrapper.style.overflowX = "";
    }
    const calendarTable = calendarWrapper.createEl("table", { cls: "linear-calendar" });
    if (this.plugin.settings.calendarWidth === "scrollable") {
      calendarTable.style.minWidth = "max-content";
      calendarTable.style.setProperty("--cell-min-width", `${this.plugin.settings.cellMinWidth}px`);
    } else {
      calendarTable.style.minWidth = "";
      calendarTable.style.removeProperty("--cell-min-width");
    }
    const maxDayCells = 37;
    const headerRow = calendarTable.createEl("thead").createEl("tr");
    headerRow.createEl("th", { cls: "month-label-cell" });
    const weekdays = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
    for (let i = 0; i < maxDayCells; i++) {
      headerRow.createEl("th", {
        text: weekdays[i % 7],
        cls: "weekday-header"
      });
    }
    headerRow.createEl("th", { cls: "month-label-cell-right" });
    const tbody = calendarTable.createEl("tbody");
    const monthNames = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    for (let month = 0; month < 12; month++) {
      await this.renderMonthRow(tbody, year, month, monthNames[month], notesWithDates, multiDayEntries, maxDayCells);
    }
    const footerRow = calendarTable.createEl("tfoot").createEl("tr");
    footerRow.createEl("td", { cls: "month-label-cell" });
    for (let i = 0; i < maxDayCells; i++) {
      footerRow.createEl("td", {
        text: weekdays[i % 7],
        cls: "weekday-header"
      });
    }
    footerRow.createEl("td", { cls: "month-label-cell-right" });
  }
  async getNotesWithDates() {
    var _a;
    const notesMap = /* @__PURE__ */ new Map();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (!this.filePassesFilter(file)) {
        continue;
      }
      const dateInfo = await this.extractDateFromFile(file);
      if (dateInfo.startDate && !isNaN(dateInfo.startDate.getTime())) {
        const key = this.dateToKey(dateInfo.startDate);
        if (!notesMap.has(key)) {
          notesMap.set(key, []);
        }
        const noteInfo = {
          file,
          startDate: dateInfo.startDate,
          endDate: dateInfo.endDate,
          isMultiDay: !!dateInfo.endDate
        };
        (_a = notesMap.get(key)) == null ? void 0 : _a.push(noteInfo);
      }
    }
    return notesMap;
  }
  filePassesFilter(file) {
    const { filterMode, filterConditions } = this.plugin.settings;
    if (filterMode === "none" || filterConditions.length === 0) {
      return true;
    }
    const matchesConditions = filterConditions.every(
      (condition) => this.evaluateCondition(file, condition)
    );
    return filterMode === "include" ? matchesConditions : !matchesConditions;
  }
  evaluateCondition(file, condition) {
    var _a, _b, _c, _d, _e, _f;
    const { property, operator, value, includeSubfolders } = condition;
    let actualValue;
    if (property === "file.name") {
      actualValue = file.name;
    } else if (property === "file.basename") {
      actualValue = file.basename;
    } else if (property === "file.folder") {
      actualValue = ((_a = file.parent) == null ? void 0 : _a.path) || "";
    } else if (property === "file.path") {
      actualValue = file.path;
    } else if (property === "file.ext") {
      actualValue = file.extension;
    } else if (property.startsWith("property:")) {
      const propertyName = property.substring(9);
      const cache = this.app.metadataCache.getFileCache(file);
      actualValue = (_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b[propertyName];
    } else {
      const cache = this.app.metadataCache.getFileCache(file);
      actualValue = (_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c[property];
    }
    switch (operator) {
      case "is":
        if (property === "file.folder" && includeSubfolders) {
          const folderPath = value ? value + "/" : "";
          return file.path.startsWith(folderPath) || ((_d = file.parent) == null ? void 0 : _d.path) === value;
        }
        return actualValue === value;
      case "isNot":
        return actualValue !== value;
      case "contains":
        if (typeof actualValue === "string") {
          return actualValue.toLowerCase().includes(value.toLowerCase());
        }
        return false;
      case "doesNotContain":
        if (typeof actualValue === "string") {
          return !actualValue.toLowerCase().includes(value.toLowerCase());
        }
        return true;
      case "startsWith":
        if (typeof actualValue === "string") {
          return actualValue.toLowerCase().startsWith(value.toLowerCase());
        }
        return false;
      case "endsWith":
        if (typeof actualValue === "string") {
          return actualValue.toLowerCase().endsWith(value.toLowerCase());
        }
        return false;
      case "matches":
        try {
          const regex = new RegExp(value);
          return regex.test(actualValue);
        } catch (e) {
          return false;
        }
      case "exists":
        return actualValue !== void 0 && actualValue !== null;
      case "doesNotExist":
        return actualValue === void 0 || actualValue === null;
      case "hasTag":
        const cache = this.app.metadataCache.getFileCache(file);
        const tags = ((_e = cache == null ? void 0 : cache.tags) == null ? void 0 : _e.map((t) => t.tag.substring(1))) || [];
        const frontmatterTags = ((_f = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _f.tags) || [];
        const allTags = [...tags, ...frontmatterTags];
        return allTags.some((tag) => tag.toLowerCase() === value.toLowerCase());
      case "matchesDatePattern":
        const datePattern = /^(\d{4}-\d{2}-\d{2})/;
        const match = file.basename.match(datePattern);
        if (!match) return false;
        if (condition.requireAdditionalText) {
          return file.basename.length > match[0].length;
        }
        return true;
      default:
        return false;
    }
  }
  /**
   * Parse a date string (YYYY-MM-DD) as a local date, not UTC.
   * This prevents timezone issues where dates shift to the previous day.
   */
  parseLocalDate(dateStr) {
    const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (!match) return null;
    const year = parseInt(match[1], 10);
    const month = parseInt(match[2], 10) - 1;
    const day = parseInt(match[3], 10);
    const date = new Date(year, month, day);
    return isNaN(date.getTime()) ? null : date;
  }
  async extractDateFromFile(file) {
    var _a, _b;
    const config = this.plugin.settings.dateExtraction;
    const result = {
      startDate: null,
      endDate: null
    };
    const startSources = [];
    if (config.startFromProperties.length > 0) {
      for (const propName of config.startFromProperties) {
        const cache = this.app.metadataCache.getFileCache(file);
        const dateStr = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[propName];
        if (dateStr) {
          const date = this.parseLocalDate(dateStr);
          if (date && !isNaN(date.getTime())) {
            startSources.push({ type: "property", date });
            break;
          }
        }
      }
    }
    if (config.startFromFilename) {
      const datePattern = /^(\d{4}-\d{2}-\d{2})/;
      const match = file.basename.match(datePattern);
      if (match) {
        const date = this.parseLocalDate(match[1]);
        if (date && !isNaN(date.getTime())) {
          startSources.push({ type: "filename", date });
        }
      }
    }
    if (startSources.length > 0) {
      if (startSources.length === 1) {
        result.startDate = startSources[0].date;
      } else {
        const prioritySource = startSources.find((s) => s.type === config.startPriority);
        result.startDate = (prioritySource == null ? void 0 : prioritySource.date) || startSources[0].date;
      }
    }
    const endSources = [];
    if (config.endFromProperties.length > 0) {
      for (const propName of config.endFromProperties) {
        const cache = this.app.metadataCache.getFileCache(file);
        const dateStr = (_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b[propName];
        if (dateStr) {
          const date = this.parseLocalDate(dateStr);
          if (date && !isNaN(date.getTime())) {
            endSources.push({ type: "property", date });
            break;
          }
        }
      }
    }
    if (config.endFromFilename) {
      const datePattern = /\d{4}-\d{2}-\d{2}/g;
      const matches = file.basename.match(datePattern);
      if (matches && matches.length >= 2) {
        const date = this.parseLocalDate(matches[1]);
        if (date && !isNaN(date.getTime())) {
          endSources.push({ type: "filename", date });
        }
      }
    }
    if (endSources.length > 0) {
      if (endSources.length === 1) {
        result.endDate = endSources[0].date;
      } else {
        const prioritySource = endSources.find((s) => s.type === config.endPriority);
        result.endDate = (prioritySource == null ? void 0 : prioritySource.date) || endSources[0].date;
      }
    }
    return result;
  }
  processMultiDayEntries(notesMap) {
    const multiDayMap = /* @__PURE__ */ new Map();
    notesMap.forEach((notes) => {
      notes.forEach((noteInfo) => {
        if (noteInfo.isMultiDay && noteInfo.endDate && !isNaN(noteInfo.endDate.getTime())) {
          let currentDate = new Date(noteInfo.startDate);
          const endDate = new Date(noteInfo.endDate);
          let monthCount = 0;
          const maxMonths = 24;
          while (currentDate <= endDate && monthCount < maxMonths) {
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            const entryId = `${noteInfo.file.path}-${currentYear}-${currentMonth}`;
            if (!multiDayMap.has(entryId)) {
              const segmentStartDay = currentDate.getDate();
              const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
              let segmentEndDay;
              if (endDate.getFullYear() === currentYear && endDate.getMonth() === currentMonth) {
                segmentEndDay = endDate.getDate();
              } else {
                segmentEndDay = lastDayOfMonth;
              }
              multiDayMap.set(entryId, {
                file: noteInfo.file,
                startDate: new Date(currentYear, currentMonth, segmentStartDay),
                endDate: new Date(currentYear, currentMonth, segmentEndDay),
                month: currentMonth,
                year: currentYear
              });
            }
            currentDate = new Date(currentYear, currentMonth + 1, 1);
            monthCount++;
          }
        }
      });
    });
    return multiDayMap;
  }
  dateToKey(date) {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
  }
  isDailyNote(file) {
    const format = this.plugin.settings.dailyNoteFormat;
    const basename = file.basename;
    const pattern = format.replace("YYYY", "\\d{4}").replace("MM", "\\d{2}").replace("DD", "\\d{2}");
    const regex = new RegExp(`^${pattern}$`);
    return regex.test(basename);
  }
  hasDateAndText(file) {
    const datePattern = /^\d{4}-\d{2}-\d{2}/;
    const match = file.basename.match(datePattern);
    if (!match) return false;
    return file.basename.length > match[0].length;
  }
  getDisplayName(file) {
    if (!this.plugin.settings.hideDateInTitle) {
      return file.basename;
    }
    const datePattern = /\d{4}-\d{2}-\d{2}/g;
    const matches = file.basename.match(datePattern);
    if (matches && matches.length > 1) {
      return file.basename;
    }
    const startDatePattern = /^\d{4}-\d{2}-\d{2}\s*/;
    return file.basename.replace(startDatePattern, "").trim() || file.basename;
  }
  shouldShowNote(file) {
    if (this.isDailyNote(file)) {
      return this.plugin.settings.showDailyNotesInCells;
    }
    if (this.hasDateAndText(file)) {
      return this.plugin.settings.showNotesWithDateAndText;
    }
    return true;
  }
  getDailyNoteFolder() {
    var _a, _b, _c, _d;
    if (this.plugin.settings.dailyNoteFolderMode === "obsidian") {
      const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        let folder = ((_d = (_c = dailyNotesPlugin.instance) == null ? void 0 : _c.options) == null ? void 0 : _d.folder) || "";
        folder = folder.replace(/^\/+|\/+$/g, "");
        return folder ? folder + "/" : "";
      }
      return "";
    } else {
      const folder = this.plugin.settings.dailyNoteCustomFolder;
      return folder ? folder + "/" : "";
    }
  }
  async findDailyNoteInFolder(filename, folderPath) {
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(folderPath) && file.name === filename) {
        return file;
      }
    }
    return null;
  }
  formatDateForDailyNote(date) {
    const format = this.plugin.settings.dailyNoteFormat;
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return format.replace("YYYY", String(year)).replace("MM", month).replace("DD", day);
  }
  async openOrCreateDailyNote(date) {
    const filename = this.formatDateForDailyNote(date);
    const folderPath = this.getDailyNoteFolder();
    const existingFile = await this.findDailyNoteInFolder(`${filename}.md`, folderPath);
    if (existingFile) {
      await this.app.workspace.getLeaf(false).openFile(existingFile);
    } else {
      const fullPath = `${folderPath}${filename}.md`;
      const newFile = await this.app.vault.create(fullPath, "");
      await this.app.workspace.getLeaf(false).openFile(newFile);
    }
  }
  async renderMonthRow(tbody, year, month, monthName, notesMap, multiDayEntries, maxDayCells) {
    const row = tbody.createEl("tr", { cls: "month-row" });
    row.createEl("td", { text: monthName, cls: "month-label" });
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startingDayOfWeek = firstDay.getDay();
    const dayCells = [];
    const activeMultiDayEntries = [];
    multiDayEntries.forEach((entry) => {
      if (entry.month === month && entry.year === year && this.shouldShowNote(entry.file)) {
        activeMultiDayEntries.push(entry);
      }
    });
    const occupiedRows = [];
    const barPositions = /* @__PURE__ */ new Map();
    activeMultiDayEntries.forEach((entry) => {
      const startDay = entry.startDate.getDate();
      const endDay = entry.endDate.getDate();
      const startCol = startingDayOfWeek + startDay - 1;
      const endCol = startingDayOfWeek + endDay - 1;
      const span = endCol - startCol + 1;
      if (span <= 0) return;
      let rowIndex = 0;
      while (occupiedRows.some(
        (occupied) => occupied.row === rowIndex && occupied.start < endCol + 1 && occupied.end > startCol
      )) {
        rowIndex++;
      }
      occupiedRows.push({ row: rowIndex, start: startCol, end: endCol + 1 });
      barPositions.set(entry.file.path + "-" + entry.month, { rowIndex, startCol, endCol, span });
    });
    const maxBarRow = occupiedRows.length > 0 ? Math.max(...occupiedRows.map((o) => o.row)) : -1;
    const topPadding = (maxBarRow + 1) * 16 + 18;
    for (let i = 0; i < startingDayOfWeek; i++) {
      const emptyCell = row.createEl("td", { cls: "day-cell empty" });
      dayCells.push(emptyCell);
    }
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, month, day);
      const dateKey = this.dateToKey(date);
      const dayCell = row.createEl("td", { cls: "day-cell" });
      const dayIndex = startingDayOfWeek + day - 1;
      const barsAbove = occupiedRows.filter((o) => o.start <= dayIndex && o.end > dayIndex).length;
      if (barsAbove > 0) {
        dayCell.style.paddingTop = `${topPadding}px`;
      }
      dayCells.push(dayCell);
      const dayNumber = dayCell.createEl("a", {
        text: String(day).padStart(2, "0"),
        cls: "day-number day-number-link"
      });
      dayNumber.onclick = async (e) => {
        e.preventDefault();
        await this.openOrCreateDailyNote(date);
      };
      const notes = notesMap.get(dateKey);
      if (notes && notes.length > 0) {
        const notesContainer = dayCell.createDiv({ cls: "day-notes" });
        const singleDayNotes = notes.filter((n) => !n.isMultiDay && this.shouldShowNote(n.file));
        singleDayNotes.forEach((noteInfo) => {
          const noteLink = notesContainer.createEl("a", {
            text: this.getDisplayName(noteInfo.file),
            cls: "note-link internal-link",
            href: "#"
          });
          noteLink.setAttr("data-href", noteInfo.file.path);
          noteLink.addEventListener("mouseenter", (event) => {
            this.showTooltip(noteInfo.file.basename, event);
          });
          noteLink.addEventListener("mouseleave", () => {
            this.hideTooltip();
          });
          noteLink.addEventListener("mouseover", (event) => {
            this.app.workspace.trigger("hover-link", {
              event,
              source: VIEW_TYPE_CALENDAR,
              hoverParent: this,
              targetEl: noteLink,
              linktext: noteInfo.file.path
            });
          });
          noteLink.onclick = (e) => {
            e.preventDefault();
            this.app.workspace.getLeaf(false).openFile(noteInfo.file);
          };
        });
      }
      if (date.getTime() === today.getTime()) {
        dayCell.addClass("today");
      }
    }
    const cellsUsed = startingDayOfWeek + daysInMonth;
    const remainingCells = maxDayCells - cellsUsed;
    for (let i = 0; i < remainingCells; i++) {
      const emptyCell = row.createEl("td", { cls: "day-cell empty" });
      dayCells.push(emptyCell);
    }
    activeMultiDayEntries.forEach((entry) => {
      const pos = barPositions.get(entry.file.path + "-" + entry.month);
      if (!pos) return;
      const firstDayCell = dayCells[pos.startCol];
      if (firstDayCell && firstDayCell.classList.contains("day-cell")) {
        const multiDayBar = firstDayCell.createEl("div", {
          cls: "multi-day-bar"
        });
        multiDayBar.style.top = `${20 + pos.rowIndex * 16}px`;
        multiDayBar.dataset.span = pos.span.toString();
        const noteLink = multiDayBar.createEl("a", {
          text: this.getDisplayName(entry.file),
          cls: "multi-day-link internal-link",
          href: "#"
        });
        noteLink.setAttr("data-href", entry.file.path);
        noteLink.addEventListener("mouseenter", (event) => {
          this.showTooltip(entry.file.basename, event);
        });
        noteLink.addEventListener("mouseleave", () => {
          this.hideTooltip();
        });
        noteLink.addEventListener("mouseover", (event) => {
          this.app.workspace.trigger("hover-link", {
            event,
            source: VIEW_TYPE_CALENDAR,
            hoverParent: this,
            targetEl: noteLink,
            linktext: entry.file.path
          });
        });
        noteLink.onclick = (e) => {
          e.preventDefault();
          this.app.workspace.getLeaf(false).openFile(entry.file);
        };
        setTimeout(() => {
          if (firstDayCell && firstDayCell.parentElement) {
            const row2 = firstDayCell.parentElement;
            const cells = Array.from(row2.querySelectorAll(".day-cell"));
            const startIndex = cells.indexOf(firstDayCell);
            if (startIndex >= 0 && startIndex + pos.span - 1 < cells.length) {
              const lastCell = cells[startIndex + pos.span - 1];
              const firstCellRect = firstDayCell.getBoundingClientRect();
              const lastCellRect = lastCell.getBoundingClientRect();
              const totalWidth = lastCellRect.right - firstCellRect.left - 6;
              multiDayBar.style.width = `${totalWidth}px`;
            }
          }
        }, 0);
      }
    });
    row.createEl("td", { text: monthName, cls: "month-label-right" });
  }
  async onClose() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    this.hideTooltip();
  }
  showTooltip(text, event) {
    this.hideTooltip();
    this.tooltip = document.body.createEl("div", {
      cls: "lc-tooltip",
      text
    });
    const x = event.clientX + 10;
    const y = event.clientY + 10;
    this.tooltip.style.left = `${x}px`;
    this.tooltip.style.top = `${y}px`;
  }
  hideTooltip() {
    if (this.tooltip) {
      this.tooltip.remove();
      this.tooltip = null;
    }
  }
};

// src/SettingsTab.ts
var import_obsidian3 = require("obsidian");

// src/FolderSuggest.ts
var import_obsidian2 = require("obsidian");
var FolderSuggest = class {
  constructor(app, inputEl) {
    this.suggestions = null;
    this.app = app;
    this.inputEl = inputEl;
    this.inputEl.addEventListener("input", () => this.updateSuggestions());
    this.inputEl.addEventListener("focus", () => this.updateSuggestions());
    this.inputEl.addEventListener("blur", () => {
      setTimeout(() => this.closeSuggestions(), 200);
    });
  }
  getAllFolders() {
    const folders = [];
    const recurse = (folder) => {
      if (folder.path) folders.push(folder.path);
      if (folder.children) {
        for (const child of folder.children) {
          if (child instanceof import_obsidian2.TFolder) {
            recurse(child);
          }
        }
      }
    };
    recurse(this.app.vault.getRoot());
    return folders;
  }
  updateSuggestions() {
    const query = this.inputEl.value.toLowerCase();
    const allFolders = this.getAllFolders();
    const matches = allFolders.filter((folder) => folder.toLowerCase().includes(query)).slice(0, 10);
    this.showSuggestions(matches);
  }
  showSuggestions(folders) {
    this.closeSuggestions();
    if (folders.length === 0) return;
    this.suggestions = document.createElement("div");
    this.suggestions.className = "suggestion-container";
    this.suggestions.style.cssText = "position: absolute; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 4px; padding: 4px; z-index: 1000; max-height: 200px; overflow-y: auto;";
    folders.forEach((folder) => {
      var _a;
      const item = document.createElement("div");
      item.className = "suggestion-item";
      item.textContent = folder;
      item.style.cssText = "padding: 4px 8px; cursor: pointer; border-radius: 3px;";
      item.addEventListener("mouseenter", () => {
        item.style.background = "var(--background-modifier-hover)";
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "";
      });
      item.addEventListener("click", () => {
        this.inputEl.value = folder;
        this.inputEl.dispatchEvent(new Event("input"));
        this.closeSuggestions();
      });
      (_a = this.suggestions) == null ? void 0 : _a.appendChild(item);
    });
    const rect = this.inputEl.getBoundingClientRect();
    this.suggestions.style.top = rect.bottom + 2 + "px";
    this.suggestions.style.left = rect.left + "px";
    this.suggestions.style.width = rect.width + "px";
    document.body.appendChild(this.suggestions);
  }
  closeSuggestions() {
    if (this.suggestions) {
      this.suggestions.remove();
      this.suggestions = null;
    }
  }
};

// src/SettingsTab.ts
var CalendarSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Linear Calendar Settings" });
    this.renderDevelopmentNotice(containerEl);
    this.renderCalendarAppearanceSection(containerEl);
    this.renderDivider(containerEl);
    this.renderDateExtractionSection(containerEl);
    this.renderDivider(containerEl);
    this.renderFiltersSection(containerEl);
    this.renderDivider(containerEl);
    this.renderDailyNotesSection(containerEl);
    this.renderDivider(containerEl);
    this.renderExperimentalSection(containerEl);
  }
  renderDevelopmentNotice(containerEl) {
    const noticeEl = containerEl.createDiv();
    noticeEl.style.cssText = "background: var(--background-secondary); border-left: 4px solid var(--interactive-accent); padding: 15px 20px; margin: 15px 0 20px 0; border-radius: 3px;";
    const titleEl = noticeEl.createEl("div");
    titleEl.style.cssText = "font-weight: 600; margin-bottom: 8px; color: var(--text-normal);";
    titleEl.textContent = "\u26A0\uFE0F Early Development";
    const textEl = noticeEl.createEl("div");
    textEl.style.cssText = "font-size: 0.95em; line-height: 1.5; color: var(--text-muted);";
    textEl.innerHTML = `
            This plugin is in early development and may undergo significant changes. The core functionality\u2014how notes are recognized and dates are extracted\u2014will remain stable. If you use properties or dates in filenames, these will continue to work.<br><br>
            New features are actively being developed. If you encounter any issues or have feedback, please reach out via <a href="https://github.com/HomefulHobo/linear-calendar-plugin-obsidian/" style="color: var(--interactive-accent);">GitHub</a> or via <a href="https://www.homefulhobo.com/contact/" style="color: var(--interactive-accent);">e-mail</a>.
        `;
  }
  renderDivider(containerEl) {
    const divider = containerEl.createEl("hr");
    divider.style.cssText = "margin: 30px 0; border: none; border-top: 1px solid var(--background-modifier-border);";
  }
  renderCalendarAppearanceSection(containerEl) {
    containerEl.createEl("h3", { text: "Calendar Appearance" });
    new import_obsidian3.Setting(containerEl).setName("Calendar width").setDesc("Choose whether the calendar fits the screen width or becomes scrollable with wider cells").addDropdown((dropdown) => {
      dropdown.addOption("fit-screen", "Fit to screen width").addOption("scrollable", "Scrollable (wider cells)").setValue(this.plugin.settings.calendarWidth).onChange(async (value) => {
        this.plugin.settings.calendarWidth = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.calendarWidth === "scrollable") {
      new import_obsidian3.Setting(containerEl).setName("Minimum cell width").setDesc("Minimum width for each day cell in pixels (default: 30)").addText((text) => text.setPlaceholder("30").setValue(String(this.plugin.settings.cellMinWidth)).onChange(async (value) => {
        const numValue = parseInt(value);
        if (!isNaN(numValue) && numValue >= 20 && numValue <= 200) {
          this.plugin.settings.cellMinWidth = numValue;
          await this.plugin.saveSettings();
        }
      }));
    }
  }
  renderDateExtractionSection(containerEl) {
    containerEl.createEl("h3", { text: "Date Extraction" });
    const desc = containerEl.createEl("p", {
      cls: "setting-item-description",
      text: "Configure how dates are extracted from your notes to display them in the calendar."
    });
    desc.style.marginTop = "-10px";
    desc.style.marginBottom = "15px";
    const examplesBox = containerEl.createDiv();
    examplesBox.style.cssText = "background: var(--background-primary); border-left: 3px solid var(--interactive-accent); padding: 12px 15px; margin-bottom: 20px; border-radius: 3px;";
    examplesBox.createEl("div", {
      text: "\u{1F4A1} Example Configurations",
      attr: { style: "font-weight: 600; margin-bottom: 8px; color: var(--interactive-accent);" }
    });
    const examplesList = examplesBox.createEl("ul");
    examplesList.style.cssText = "margin: 0; padding-left: 20px; font-size: 0.9em; line-height: 1.6;";
    const examples = [
      "Use <code>date</code> and <code>date_end</code> properties",
      "Use filename like <code>2024-01-15 \u2013 2024-01-20 Event.md</code> for date ranges",
      "Mix sources: filename for start date + <code>date_end</code> property for end date",
      "Add multiple property names to check (e.g., <code>date</code>, <code>lincal_date</code>, <code>scheduled</code>)"
    ];
    examples.forEach((example) => {
      const li = examplesList.createEl("li");
      li.innerHTML = example;
      li.style.marginBottom = "4px";
    });
    const config = this.plugin.settings.dateExtraction;
    const startSection = containerEl.createDiv();
    startSection.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px; margin-bottom: 20px;";
    startSection.createEl("h4", { text: "Start Date", attr: { style: "margin-top: 0;" } });
    const startPropsContainer = startSection.createDiv();
    startPropsContainer.style.cssText = "margin-bottom: 15px;";
    const startPropsLabel = startPropsContainer.createEl("label");
    startPropsLabel.style.cssText = "display: flex; align-items: center; gap: 8px; margin-bottom: 8px;";
    const startPropsCheckbox = startPropsLabel.createEl("input", { type: "checkbox" });
    startPropsCheckbox.checked = config.startFromProperties.length > 0;
    startPropsLabel.createEl("span", { text: "From properties", attr: { style: "font-weight: 500;" } });
    const startPropsListContainer = startPropsContainer.createDiv();
    startPropsListContainer.style.cssText = "margin-left: 28px;";
    if (config.startFromProperties.length === 0) {
      startPropsListContainer.style.display = "none";
    }
    const renderStartPropsList = () => {
      startPropsListContainer.empty();
      if (config.startFromProperties.length > 0) {
        startPropsListContainer.createEl("div", {
          text: "Properties are checked in order from top to bottom. Drag to reorder.",
          attr: { style: "font-size: 0.85em; color: var(--text-muted); margin-bottom: 8px; font-style: italic;" }
        });
      }
      let draggedIndex = null;
      config.startFromProperties.forEach((prop, index) => {
        const propRow = startPropsListContainer.createDiv();
        propRow.style.cssText = "display: flex; gap: 5px; margin-bottom: 5px; align-items: center; cursor: grab;";
        propRow.draggable = true;
        propRow.setAttribute("data-index", index.toString());
        const dragHandle = propRow.createEl("span", { text: "\u22EE\u22EE" });
        dragHandle.style.cssText = "cursor: grab; color: var(--text-muted); user-select: none; padding: 0 4px;";
        const propInput = propRow.createEl("input", {
          type: "text",
          value: prop,
          attr: { placeholder: "Property name" }
        });
        propInput.style.cssText = "flex: 1; padding: 4px 8px;";
        propInput.onchange = async (e) => {
          config.startFromProperties[index] = e.target.value;
          await this.plugin.saveSettings();
        };
        const removeBtn = propRow.createEl("button", { text: "\xD7" });
        removeBtn.style.cssText = "padding: 2px 8px; cursor: pointer;";
        removeBtn.onclick = async () => {
          config.startFromProperties.splice(index, 1);
          await this.plugin.saveSettings();
          renderStartPropsList();
        };
        propRow.addEventListener("dragstart", () => {
          draggedIndex = index;
          propRow.style.opacity = "0.4";
          propRow.style.cursor = "grabbing";
        });
        propRow.addEventListener("dragend", () => {
          propRow.style.opacity = "1";
          propRow.style.cursor = "grab";
        });
        propRow.addEventListener("dragover", (e) => {
          e.preventDefault();
          if (draggedIndex !== null && draggedIndex !== index) {
            propRow.style.borderTop = "2px solid var(--interactive-accent)";
          }
        });
        propRow.addEventListener("dragleave", () => {
          propRow.style.borderTop = "";
        });
        propRow.addEventListener("drop", async (e) => {
          e.preventDefault();
          propRow.style.borderTop = "";
          if (draggedIndex !== null && draggedIndex !== index) {
            const draggedItem = config.startFromProperties[draggedIndex];
            config.startFromProperties.splice(draggedIndex, 1);
            const newIndex = draggedIndex < index ? index - 1 : index;
            config.startFromProperties.splice(newIndex, 0, draggedItem);
            await this.plugin.saveSettings();
            renderStartPropsList();
          }
          draggedIndex = null;
        });
      });
      const addBtn = startPropsListContainer.createEl("button", { text: "+ Add property" });
      addBtn.style.cssText = "padding: 4px 8px; margin-top: 5px;";
      addBtn.onclick = async () => {
        config.startFromProperties.push("");
        await this.plugin.saveSettings();
        renderStartPropsList();
      };
    };
    renderStartPropsList();
    startPropsCheckbox.onchange = async (e) => {
      if (e.target.checked) {
        if (config.startFromProperties.length === 0) {
          config.startFromProperties.push("date");
        }
        startPropsListContainer.style.display = "block";
      } else {
        config.startFromProperties = [];
        startPropsListContainer.style.display = "none";
      }
      await this.plugin.saveSettings();
      renderStartPropsList();
    };
    const startFilenameLabel = startSection.createEl("label");
    startFilenameLabel.style.cssText = "display: flex; align-items: center; gap: 8px; margin-bottom: 15px;";
    const startFilenameCheckbox = startFilenameLabel.createEl("input", { type: "checkbox" });
    startFilenameCheckbox.checked = config.startFromFilename;
    startFilenameLabel.createEl("span", { text: "From filename (first YYYY-MM-DD pattern)", attr: { style: "font-weight: 500;" } });
    startFilenameCheckbox.onchange = async (e) => {
      config.startFromFilename = e.target.checked;
      await this.plugin.saveSettings();
      updatePriorityVisibility();
    };
    const startPriorityContainer = startSection.createDiv();
    startPriorityContainer.style.cssText = "margin-top: 10px; padding: 10px; background: var(--background-primary); border-radius: 3px;";
    const updatePriorityVisibility = () => {
      const bothEnabled = config.startFromProperties.length > 0 && config.startFromFilename;
      startPriorityContainer.style.display = bothEnabled ? "block" : "none";
    };
    startPriorityContainer.createEl("div", {
      text: "When both are available, prioritize:",
      attr: { style: "margin-bottom: 8px; font-size: 0.9em; color: var(--text-muted);" }
    });
    const priorityOptions = startPriorityContainer.createDiv();
    priorityOptions.style.cssText = "display: flex; gap: 15px;";
    const propRadioLabel = priorityOptions.createEl("label");
    propRadioLabel.style.cssText = "display: flex; align-items: center; gap: 5px;";
    const propRadio = propRadioLabel.createEl("input", { type: "radio", attr: { name: "start-priority" } });
    propRadio.checked = config.startPriority === "property";
    propRadioLabel.createEl("span", { text: "Property" });
    propRadio.onchange = async () => {
      config.startPriority = "property";
      await this.plugin.saveSettings();
    };
    const filenameRadioLabel = priorityOptions.createEl("label");
    filenameRadioLabel.style.cssText = "display: flex; align-items: center; gap: 5px;";
    const filenameRadio = filenameRadioLabel.createEl("input", { type: "radio", attr: { name: "start-priority" } });
    filenameRadio.checked = config.startPriority === "filename";
    filenameRadioLabel.createEl("span", { text: "Filename" });
    filenameRadio.onchange = async () => {
      config.startPriority = "filename";
      await this.plugin.saveSettings();
    };
    updatePriorityVisibility();
    const endSection = containerEl.createDiv();
    endSection.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px;";
    endSection.createEl("h4", { text: "End Date (for multi-day events)", attr: { style: "margin-top: 0;" } });
    const endPropsContainer = endSection.createDiv();
    endPropsContainer.style.cssText = "margin-bottom: 15px;";
    const endPropsLabel = endPropsContainer.createEl("label");
    endPropsLabel.style.cssText = "display: flex; align-items: center; gap: 8px; margin-bottom: 8px;";
    const endPropsCheckbox = endPropsLabel.createEl("input", { type: "checkbox" });
    endPropsCheckbox.checked = config.endFromProperties.length > 0;
    endPropsLabel.createEl("span", { text: "From properties", attr: { style: "font-weight: 500;" } });
    const endPropsListContainer = endPropsContainer.createDiv();
    endPropsListContainer.style.cssText = "margin-left: 28px;";
    if (config.endFromProperties.length === 0) {
      endPropsListContainer.style.display = "none";
    }
    const renderEndPropsList = () => {
      endPropsListContainer.empty();
      if (config.endFromProperties.length > 0) {
        endPropsListContainer.createEl("div", {
          text: "Properties are checked in order from top to bottom. Drag to reorder.",
          attr: { style: "font-size: 0.85em; color: var(--text-muted); margin-bottom: 8px; font-style: italic;" }
        });
      }
      let draggedIndex = null;
      config.endFromProperties.forEach((prop, index) => {
        const propRow = endPropsListContainer.createDiv();
        propRow.style.cssText = "display: flex; gap: 5px; margin-bottom: 5px; align-items: center; cursor: grab;";
        propRow.draggable = true;
        propRow.setAttribute("data-index", index.toString());
        const dragHandle = propRow.createEl("span", { text: "\u22EE\u22EE" });
        dragHandle.style.cssText = "cursor: grab; color: var(--text-muted); user-select: none; padding: 0 4px;";
        const propInput = propRow.createEl("input", {
          type: "text",
          value: prop,
          attr: { placeholder: "Property name" }
        });
        propInput.style.cssText = "flex: 1; padding: 4px 8px;";
        propInput.onchange = async (e) => {
          config.endFromProperties[index] = e.target.value;
          await this.plugin.saveSettings();
        };
        const removeBtn = propRow.createEl("button", { text: "\xD7" });
        removeBtn.style.cssText = "padding: 2px 8px; cursor: pointer;";
        removeBtn.onclick = async () => {
          config.endFromProperties.splice(index, 1);
          await this.plugin.saveSettings();
          renderEndPropsList();
        };
        propRow.addEventListener("dragstart", () => {
          draggedIndex = index;
          propRow.style.opacity = "0.4";
          propRow.style.cursor = "grabbing";
        });
        propRow.addEventListener("dragend", () => {
          propRow.style.opacity = "1";
          propRow.style.cursor = "grab";
        });
        propRow.addEventListener("dragover", (e) => {
          e.preventDefault();
          if (draggedIndex !== null && draggedIndex !== index) {
            propRow.style.borderTop = "2px solid var(--interactive-accent)";
          }
        });
        propRow.addEventListener("dragleave", () => {
          propRow.style.borderTop = "";
        });
        propRow.addEventListener("drop", async (e) => {
          e.preventDefault();
          propRow.style.borderTop = "";
          if (draggedIndex !== null && draggedIndex !== index) {
            const draggedItem = config.endFromProperties[draggedIndex];
            config.endFromProperties.splice(draggedIndex, 1);
            const newIndex = draggedIndex < index ? index - 1 : index;
            config.endFromProperties.splice(newIndex, 0, draggedItem);
            await this.plugin.saveSettings();
            renderEndPropsList();
          }
          draggedIndex = null;
        });
      });
      const addBtn = endPropsListContainer.createEl("button", { text: "+ Add property" });
      addBtn.style.cssText = "padding: 4px 8px; margin-top: 5px;";
      addBtn.onclick = async () => {
        config.endFromProperties.push("");
        await this.plugin.saveSettings();
        renderEndPropsList();
      };
    };
    renderEndPropsList();
    endPropsCheckbox.onchange = async (e) => {
      if (e.target.checked) {
        if (config.endFromProperties.length === 0) {
          config.endFromProperties.push("date_end");
        }
        endPropsListContainer.style.display = "block";
      } else {
        config.endFromProperties = [];
        endPropsListContainer.style.display = "none";
      }
      await this.plugin.saveSettings();
      renderEndPropsList();
      updateEndPriorityVisibility();
    };
    const endFilenameLabel = endSection.createEl("label");
    endFilenameLabel.style.cssText = "display: flex; align-items: center; gap: 8px; margin-bottom: 15px;";
    const endFilenameCheckbox = endFilenameLabel.createEl("input", { type: "checkbox" });
    endFilenameCheckbox.checked = config.endFromFilename;
    endFilenameLabel.createEl("span", { text: "From filename (second YYYY-MM-DD pattern)", attr: { style: "font-weight: 500;" } });
    endFilenameCheckbox.onchange = async (e) => {
      config.endFromFilename = e.target.checked;
      await this.plugin.saveSettings();
      updateEndPriorityVisibility();
    };
    const endPriorityContainer = endSection.createDiv();
    endPriorityContainer.style.cssText = "margin-top: 10px; padding: 10px; background: var(--background-primary); border-radius: 3px;";
    const updateEndPriorityVisibility = () => {
      const bothEnabled = config.endFromProperties.length > 0 && config.endFromFilename;
      endPriorityContainer.style.display = bothEnabled ? "block" : "none";
    };
    endPriorityContainer.createEl("div", {
      text: "When both are available, prioritize:",
      attr: { style: "margin-bottom: 8px; font-size: 0.9em; color: var(--text-muted);" }
    });
    const endPriorityOptions = endPriorityContainer.createDiv();
    endPriorityOptions.style.cssText = "display: flex; gap: 15px;";
    const endPropRadioLabel = endPriorityOptions.createEl("label");
    endPropRadioLabel.style.cssText = "display: flex; align-items: center; gap: 5px;";
    const endPropRadio = endPropRadioLabel.createEl("input", { type: "radio", attr: { name: "end-priority" } });
    endPropRadio.checked = config.endPriority === "property";
    endPropRadioLabel.createEl("span", { text: "Property" });
    endPropRadio.onchange = async () => {
      config.endPriority = "property";
      await this.plugin.saveSettings();
    };
    const endFilenameRadioLabel = endPriorityOptions.createEl("label");
    endFilenameRadioLabel.style.cssText = "display: flex; align-items: center; gap: 5px;";
    const endFilenameRadio = endFilenameRadioLabel.createEl("input", { type: "radio", attr: { name: "end-priority" } });
    endFilenameRadio.checked = config.endPriority === "filename";
    endFilenameRadioLabel.createEl("span", { text: "Filename" });
    endFilenameRadio.onchange = async () => {
      config.endPriority = "filename";
      await this.plugin.saveSettings();
    };
    updateEndPriorityVisibility();
  }
  renderFiltersSection(containerEl) {
    containerEl.createEl("h3", { text: "Filters (Optional)" });
    const desc = containerEl.createEl("p", {
      cls: "setting-item-description",
      text: "By default, all notes with valid dates are shown. Add filters to include or exclude specific notes."
    });
    desc.style.marginTop = "-10px";
    desc.style.marginBottom = "15px";
    const filterModeContainer = containerEl.createDiv();
    filterModeContainer.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px; margin-bottom: 15px;";
    filterModeContainer.createEl("div", {
      text: "Filter mode:",
      attr: { style: "margin-bottom: 10px; font-weight: 500;" }
    });
    const modeOptions = filterModeContainer.createDiv();
    modeOptions.style.cssText = "display: flex; flex-direction: column; gap: 8px;";
    const createModeOption = (value, label, description) => {
      const optionLabel = modeOptions.createEl("label");
      optionLabel.style.cssText = "display: flex; align-items: flex-start; gap: 8px; cursor: pointer;";
      const radio = optionLabel.createEl("input", {
        type: "radio",
        attr: { name: "filter-mode" }
      });
      radio.checked = this.plugin.settings.filterMode === value;
      radio.style.cssText = "margin-top: 3px;";
      const textContainer = optionLabel.createDiv();
      textContainer.createEl("div", { text: label, attr: { style: "font-weight: 500;" } });
      textContainer.createEl("div", {
        text: description,
        attr: { style: "font-size: 0.9em; color: var(--text-muted);" }
      });
      radio.onchange = async () => {
        this.plugin.settings.filterMode = value;
        await this.plugin.saveSettings();
        this.display();
      };
    };
    createModeOption("none", "Show all notes", "Display every note that has a valid date");
    createModeOption("include", "Only include notes that match", "Only show notes that meet all the conditions below");
    createModeOption("exclude", "Exclude notes that match", "Hide notes that meet all the conditions below");
    if (this.plugin.settings.filterMode !== "none") {
      const conditionsContainer = containerEl.createDiv();
      conditionsContainer.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px;";
      conditionsContainer.createEl("h4", {
        text: "Conditions",
        attr: { style: "margin-top: 0; margin-bottom: 10px;" }
      });
      if (this.plugin.settings.filterConditions.length === 0) {
        conditionsContainer.createEl("p", {
          text: 'No conditions added yet. Click "+ Add condition" to get started.',
          attr: { style: "color: var(--text-muted); font-style: italic;" }
        });
      } else {
        this.plugin.settings.filterConditions.forEach((condition, index) => {
          this.renderCondition(conditionsContainer, condition, index);
        });
      }
      const addCondBtn = conditionsContainer.createEl("button", { text: "+ Add condition" });
      addCondBtn.style.cssText = "padding: 6px 12px; margin-top: 10px;";
      addCondBtn.onclick = async () => {
        this.plugin.settings.filterConditions.push({
          property: "file.folder",
          operator: "is",
          value: ""
        });
        await this.plugin.saveSettings();
        this.display();
      };
    }
  }
  renderCondition(container, condition, condIndex) {
    const condEl = container.createDiv();
    condEl.style.cssText = "display: flex; gap: 5px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; padding: 8px; background: var(--background-primary); border-radius: 3px;";
    const propertySelect = condEl.createEl("select");
    propertySelect.style.cssText = "padding: 4px 8px;";
    const properties = [
      { value: "file.name", label: "File name" },
      { value: "file.basename", label: "File basename" },
      { value: "file.folder", label: "Folder" },
      { value: "file.path", label: "File path" },
      { value: "file.ext", label: "Extension" },
      { value: "custom", label: "Custom property..." }
    ];
    properties.forEach((prop) => {
      const option = propertySelect.createEl("option", {
        text: prop.label,
        value: prop.value
      });
      if (condition.property === prop.value || prop.value === "custom" && !properties.find((p) => p.value === condition.property)) {
        option.selected = true;
      }
    });
    propertySelect.onchange = async (e) => {
      if (e.target.value === "custom") {
        condition.property = "";
      } else {
        condition.property = e.target.value;
      }
      await this.plugin.saveSettings();
      this.display();
    };
    if (propertySelect.value === "custom" || !properties.find((p) => p.value === condition.property)) {
      const customInput = condEl.createEl("input", {
        type: "text",
        attr: { placeholder: "property name" },
        value: condition.property
      });
      customInput.style.cssText = "padding: 4px 8px; width: 120px;";
      customInput.onchange = async (e) => {
        condition.property = e.target.value;
        await this.plugin.saveSettings();
      };
    }
    const operatorSelect = condEl.createEl("select");
    operatorSelect.style.cssText = "padding: 4px 8px;";
    const operators = [
      { value: "is", label: "is" },
      { value: "isNot", label: "is not" },
      { value: "contains", label: "contains" },
      { value: "doesNotContain", label: "does not contain" },
      { value: "startsWith", label: "starts with" },
      { value: "endsWith", label: "ends with" },
      { value: "matches", label: "matches regex" },
      { value: "exists", label: "exists" },
      { value: "doesNotExist", label: "does not exist" },
      { value: "hasTag", label: "has tag" },
      { value: "matchesDatePattern", label: "matches date pattern" }
    ];
    operators.forEach((op) => {
      const option = operatorSelect.createEl("option", {
        text: op.label,
        value: op.value
      });
      if (condition.operator === op.value) {
        option.selected = true;
      }
    });
    operatorSelect.onchange = async (e) => {
      condition.operator = e.target.value;
      await this.plugin.saveSettings();
      this.display();
    };
    if (!["exists", "doesNotExist"].includes(condition.operator)) {
      const valueInput = condEl.createEl("input", {
        type: "text",
        attr: { placeholder: "value" },
        value: condition.value || ""
      });
      valueInput.style.cssText = "padding: 4px 8px; flex: 1; min-width: 120px;";
      valueInput.onchange = async (e) => {
        condition.value = e.target.value;
        await this.plugin.saveSettings();
      };
    }
    if (condition.property === "file.folder" && condition.operator === "is") {
      const subfolderLabel = condEl.createEl("label");
      subfolderLabel.style.cssText = "display: flex; align-items: center; gap: 5px;";
      const subfolderCheckbox = subfolderLabel.createEl("input", { type: "checkbox" });
      subfolderCheckbox.checked = condition.includeSubfolders || false;
      subfolderCheckbox.onchange = async (e) => {
        condition.includeSubfolders = e.target.checked;
        await this.plugin.saveSettings();
      };
      subfolderLabel.createEl("span", { text: "Include subfolders" });
    }
    if (condition.operator === "matchesDatePattern") {
      const requireTextLabel = condEl.createEl("label");
      requireTextLabel.style.cssText = "display: flex; align-items: center; gap: 5px;";
      const requireTextCheckbox = requireTextLabel.createEl("input", { type: "checkbox" });
      requireTextCheckbox.checked = condition.requireAdditionalText || false;
      requireTextCheckbox.onchange = async (e) => {
        condition.requireAdditionalText = e.target.checked;
        await this.plugin.saveSettings();
      };
      requireTextLabel.createEl("span", { text: "and has text after date" });
    }
    const deleteBtn = condEl.createEl("button", { text: "\xD7" });
    deleteBtn.style.cssText = "padding: 2px 10px; cursor: pointer; font-size: 1.2em;";
    deleteBtn.onclick = async () => {
      this.plugin.settings.filterConditions.splice(condIndex, 1);
      await this.plugin.saveSettings();
      this.display();
    };
  }
  renderDailyNotesSection(containerEl) {
    containerEl.createEl("h3", { text: "Daily Notes" });
    const desc = containerEl.createEl("p", {
      cls: "setting-item-description",
      text: "Daily notes are always accessible via the day numbers in the calendar. You can click any day number to open or create a daily note."
    });
    desc.style.marginTop = "-10px";
    desc.style.marginBottom = "15px";
    new import_obsidian3.Setting(containerEl).setName("Daily note format").setDesc("Format for daily note filenames (use YYYY for year, MM for month, DD for day)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dailyNoteFormat).onChange(async (value) => {
      this.plugin.settings.dailyNoteFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Daily notes folder mode").setDesc("Choose where to look for and create daily notes").addDropdown((dropdown) => {
      dropdown.addOption("obsidian", `Use native Daily Notes plugin's "New file location"`).addOption("custom", "Use custom folder").setValue(this.plugin.settings.dailyNoteFolderMode).onChange(async (value) => {
        this.plugin.settings.dailyNoteFolderMode = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.dailyNoteFolderMode === "custom") {
      new import_obsidian3.Setting(containerEl).setName("Custom daily notes folder").setDesc("Folder path for daily notes. Searches subfolders too.").addText((text) => {
        text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNoteCustomFolder).onChange(async (value) => {
          const cleaned = value.replace(/^\/+|\/+$/g, "");
          this.plugin.settings.dailyNoteCustomFolder = cleaned;
          await this.plugin.saveSettings();
        });
        new FolderSuggest(this.app, text.inputEl);
      });
    }
    const displaySection = containerEl.createDiv();
    displaySection.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px; margin-top: 15px;";
    displaySection.createEl("h4", { text: "Display Options", attr: { style: "margin-top: 0;" } });
    new import_obsidian3.Setting(displaySection).setName("Show daily notes in calendar cells").setDesc("Display daily notes as separate note cells in addition to the day number links").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDailyNotesInCells).onChange(async (value) => {
      this.plugin.settings.showDailyNotesInCells = value;
      await this.plugin.saveSettings();
    }));
    const dateTextSection = containerEl.createDiv();
    dateTextSection.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px; margin-top: 15px;";
    dateTextSection.createEl("h4", { text: "Notes with Date and Text in Title", attr: { style: "margin-top: 0;" } });
    new import_obsidian3.Setting(dateTextSection).setName("Show notes with date and text").setDesc('Display notes that have both a date and additional text in their filename (e.g., "2024-01-15 Meeting Notes")').addToggle((toggle) => toggle.setValue(this.plugin.settings.showNotesWithDateAndText).onChange(async (value) => {
      this.plugin.settings.showNotesWithDateAndText = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(dateTextSection).setName("Hide date portion in titles").setDesc('When displaying notes in the calendar, hide the date portion of the title and only show the text (e.g., show "Meeting Notes" instead of "2024-01-15 Meeting Notes")').addToggle((toggle) => toggle.setValue(this.plugin.settings.hideDateInTitle).onChange(async (value) => {
      this.plugin.settings.hideDateInTitle = value;
      await this.plugin.saveSettings();
    }));
  }
  renderExperimentalSection(containerEl) {
    const headerContainer = containerEl.createDiv();
    headerContainer.style.cssText = "display: flex; align-items: center; gap: 10px; margin-bottom: 10px;";
    headerContainer.createEl("h3", { text: "Note Title Display" });
    const badge = headerContainer.createEl("span");
    badge.textContent = "Experimental";
    badge.style.cssText = "background: var(--interactive-accent); color: var(--text-on-accent); padding: 2px 8px; border-radius: 3px; font-size: 0.75em; font-weight: 600;";
    const desc = containerEl.createEl("p", {
      cls: "setting-item-description",
      text: "Test different ways to display note titles in calendar cells. These features are experimental and may change."
    });
    desc.style.marginTop = "-10px";
    desc.style.marginBottom = "15px";
    const exp = this.plugin.settings.experimental;
    const expSection = containerEl.createDiv();
    expSection.style.cssText = "background: var(--background-secondary); padding: 15px; border-radius: 5px;";
    new import_obsidian3.Setting(expSection).setName("Multi-line note names").setDesc("Allow note names to wrap to multiple lines instead of truncating. Best for wider cells.").addToggle((toggle) => toggle.setValue(exp.multilineNotes).onChange(async (value) => {
      exp.multilineNotes = value;
      if (value) {
        exp.verticalText = false;
      }
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian3.Setting(expSection).setName("Vertical text rotation").setDesc("Rotate note names 90 degrees vertically. Creative use of vertical space.").addToggle((toggle) => toggle.setValue(exp.verticalText).onChange(async (value) => {
      exp.verticalText = value;
      if (value) {
        exp.multilineNotes = false;
      }
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian3.Setting(expSection).setName("Compact font size").setDesc("Use smaller font size (0.75em) for note names to fit more text.").addToggle((toggle) => toggle.setValue(exp.compactFontSize).onChange(async (value) => {
      exp.compactFontSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(expSection).setName("Condensed letter spacing").setDesc("Reduce spacing between letters to fit more text in the same space.").addToggle((toggle) => toggle.setValue(exp.condensedLetters).onChange(async (value) => {
      exp.condensedLetters = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var LinearCalendarPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_CALENDAR,
      (leaf) => new LinearCalendarView(leaf, this)
    );
    this.addRibbonIcon("calendar-range", "Open Linear Calendar", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-linear-calendar",
      name: "Open Linear Calendar",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new CalendarSettingTab(this.app, this));
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CALENDAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_CALENDAR, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CALENDAR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CALENDAR);
    for (const leaf of leaves) {
      if (leaf.view instanceof LinearCalendarView) {
        await leaf.view.reload();
      }
    }
  }
};
