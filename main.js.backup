'use strict';

var obsidian = require('obsidian');

const DEFAULT_SETTINGS = {
    currentYear: new Date().getFullYear(),
    dailyNoteFormat: 'YYYY-MM-DD',
    dailyNoteFolderMode: 'obsidian', // 'obsidian' or 'custom'
    dailyNoteCustomFolder: '',
    rules: [
        // Default rule for backward compatibility
        {
            id: 'default-rule',
            name: 'Default Rule',
            description: '',
            enabled: true,
            filterGroups: [
                {
                    logic: 'AND',
                    conditions: []
                }
            ],
            dateExtraction: {
                startDate: {
                    method: 'property',
                    propertyName: 'lincal_date'
                },
                endDate: {
                    method: 'property',
                    propertyName: 'lincal_date_end'
                }
            }
        }
    ]
};

const VIEW_TYPE_CALENDAR = "linear-calendar-view";

class LinearCalendarView extends obsidian.ItemView {
    constructor(leaf, plugin) {
        super(leaf);
        this.plugin = plugin;
    }

    getViewType() {
        return VIEW_TYPE_CALENDAR;
    }

    getDisplayText() {
        return "Linear Calendar";
    }

    getIcon() {
        return "calendar";
    }

    async onOpen() {
        const container = this.containerEl.children[1];
        container.empty();
        container.addClass('linear-calendar-container');
        
        await this.renderCalendar(container);
        
        // Add resize listener to recalculate multi-day bar widths
        this.resizeObserver = new ResizeObserver(() => {
            this.updateMultiDayBarWidths(container);
        });
        this.resizeObserver.observe(container);
    }
    
    updateMultiDayBarWidths(container) {
        const bars = container.querySelectorAll('.multi-day-bar[data-span]');
        bars.forEach(bar => {
            const span = parseInt(bar.dataset.span);
            const parentCell = bar.parentElement;
            if (parentCell && parentCell.parentElement) {
                const row = parentCell.parentElement;
                const cells = Array.from(row.querySelectorAll('.day-cell'));
                const startIndex = cells.indexOf(parentCell);
                
                if (startIndex >= 0 && startIndex + span - 1 < cells.length) {
                    const lastCell = cells[startIndex + span - 1];
                    
                    const firstCellRect = parentCell.getBoundingClientRect();
                    const lastCellRect = lastCell.getBoundingClientRect();
                    
                    const totalWidth = lastCellRect.right - firstCellRect.left - 6;
                    bar.style.width = `${totalWidth}px`;
                }
            }
        });
    }

    async renderCalendar(container) {
        const year = this.plugin.settings.currentYear;
        
        const header = container.createDiv({ cls: 'calendar-header' });
        const prevBtn = header.createEl('button', { text: 'â†', cls: 'year-nav-btn' });
        header.createEl('span', { text: `${year}`, cls: 'year-title' });
        const nextBtn = header.createEl('button', { text: 'â†’', cls: 'year-nav-btn' });

        prevBtn.onclick = async () => {
            this.plugin.settings.currentYear--;
            await this.plugin.saveSettings();
            container.empty();
            await this.renderCalendar(container);
        };

        nextBtn.onclick = async () => {
            this.plugin.settings.currentYear++;
            await this.plugin.saveSettings();
            container.empty();
            await this.renderCalendar(container);
        };

        const notesWithDates = await this.getNotesWithDates();
        const multiDayEntries = this.processMultiDayEntries(notesWithDates, year);
        
        const calendarWrapper = container.createDiv({ cls: 'calendar-wrapper' });
        const calendarTable = calendarWrapper.createEl('table', { cls: 'linear-calendar' });

        const maxDayCells = 37;
        
        const headerRow = calendarTable.createEl('thead').createEl('tr');
        headerRow.createEl('th', { cls: 'month-label-cell' });
        
        const weekdays = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
        for (let i = 0; i < maxDayCells; i++) {
            headerRow.createEl('th', { 
                text: weekdays[i % 7], 
                cls: 'weekday-header' 
            });
        }
        headerRow.createEl('th', { cls: 'month-label-cell-right' });

        const tbody = calendarTable.createEl('tbody');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        for (let month = 0; month < 12; month++) {
            await this.renderMonthRow(tbody, year, month, monthNames[month], notesWithDates, multiDayEntries, maxDayCells);
        }

        const footerRow = calendarTable.createEl('tfoot').createEl('tr');
        footerRow.createEl('td', { cls: 'month-label-cell' });
        for (let i = 0; i < maxDayCells; i++) {
            footerRow.createEl('td', { 
                text: weekdays[i % 7], 
                cls: 'weekday-header' 
            });
        }
        footerRow.createEl('td', { cls: 'month-label-cell-right' });
    }

    async getNotesWithDates() {
        const notesMap = new Map();
        const files = this.app.vault.getMarkdownFiles();

        // Process each rule
        for (const rule of this.plugin.settings.rules) {
            if (!rule.enabled) continue;

            for (const file of files) {
                // Check if file matches this rule's filter
                if (this.fileMatchesRule(file, rule)) {
                    // Extract date based on this rule's date extraction config
                    const dateInfo = await this.extractDateFromFile(file, rule.dateExtraction);
                    
                    if (dateInfo.startDate && !isNaN(dateInfo.startDate.getTime())) {
                        const key = this.dateToKey(dateInfo.startDate);
                        if (!notesMap.has(key)) {
                            notesMap.set(key, []);
                        }
                        
                        const noteInfo = {
                            file: file,
                            startDate: dateInfo.startDate,
                            endDate: dateInfo.endDate,
                            isMultiDay: !!dateInfo.endDate
                        };
                        
                        notesMap.get(key)?.push(noteInfo);
                    }
                }
            }
        }

        return notesMap;
    }

    fileMatchesRule(file, rule) {
        // If no filter groups or conditions, match all files
        if (!rule.filterGroups || rule.filterGroups.length === 0) {
            return true;
        }

        // Evaluate each filter group (groups are OR-ed together)
        for (const group of rule.filterGroups) {
            if (this.evaluateFilterGroup(file, group)) {
                return true;
            }
        }

        return false;
    }

    evaluateFilterGroup(file, group) {
        if (!group.conditions || group.conditions.length === 0) {
            return true;
        }

        const logic = group.logic || 'AND';
        
        if (logic === 'AND') {
            // All conditions must be true
            return group.conditions.every(condition => this.evaluateCondition(file, condition));
        } else if (logic === 'OR') {
            // At least one condition must be true
            return group.conditions.some(condition => this.evaluateCondition(file, condition));
        } else if (logic === 'NOT') {
            // None of the conditions should be true
            return !group.conditions.some(condition => this.evaluateCondition(file, condition));
        }

        return false;
    }

    evaluateCondition(file, condition) {
        const { property, operator, value, includeSubfolders } = condition;

        // Get the actual value to compare
        let actualValue;
        
        if (property === 'file.name') {
            actualValue = file.name;
        } else if (property === 'file.basename') {
            actualValue = file.basename;
        } else if (property === 'file.folder') {
            actualValue = file.parent?.path || '';
        } else if (property === 'file.path') {
            actualValue = file.path;
        } else if (property === 'file.ext') {
            actualValue = file.extension;
        } else if (property.startsWith('property:')) {
            // Custom property
            const propertyName = property.substring(9);
            const cache = this.app.metadataCache.getFileCache(file);
            actualValue = cache?.frontmatter?.[propertyName];
        } else {
            // Assume it's a custom property name
            const cache = this.app.metadataCache.getFileCache(file);
            actualValue = cache?.frontmatter?.[property];
        }

        // Apply operator
        switch (operator) {
            case 'is':
                if (property === 'file.folder' && includeSubfolders) {
                    // For folders with subfolders, check if path starts with the folder
                    const folderPath = value ? value + '/' : '';
                    return file.path.startsWith(folderPath) || file.parent?.path === value;
                }
                return actualValue === value;
                
            case 'isNot':
                return actualValue !== value;
                
            case 'contains':
                if (typeof actualValue === 'string') {
                    return actualValue.toLowerCase().includes(value.toLowerCase());
                }
                return false;
                
            case 'doesNotContain':
                if (typeof actualValue === 'string') {
                    return !actualValue.toLowerCase().includes(value.toLowerCase());
                }
                return true;
                
            case 'startsWith':
                if (typeof actualValue === 'string') {
                    return actualValue.toLowerCase().startsWith(value.toLowerCase());
                }
                return false;
                
            case 'endsWith':
                if (typeof actualValue === 'string') {
                    return actualValue.toLowerCase().endsWith(value.toLowerCase());
                }
                return false;
                
            case 'matches':
                // Regex matching
                try {
                    const regex = new RegExp(value);
                    return regex.test(actualValue);
                } catch {
                    return false;
                }
                
            case 'exists':
                return actualValue !== undefined && actualValue !== null;
                
            case 'doesNotExist':
                return actualValue === undefined || actualValue === null;
                
            case 'hasTag':
                const cache = this.app.metadataCache.getFileCache(file);
                const tags = cache?.tags?.map(t => t.tag.substring(1)) || [];
                const frontmatterTags = cache?.frontmatter?.tags || [];
                const allTags = [...tags, ...frontmatterTags];
                return allTags.some(tag => tag.toLowerCase() === value.toLowerCase());
                
            case 'matchesDatePattern':
                // Special operator for YYYY-MM-DD pattern
                const datePattern = /^(\d{4}-\d{2}-\d{2})/;
                const match = file.basename.match(datePattern);
                
                if (!match) return false;
                
                if (condition.requireAdditionalText) {
                    // Must have text after the date
                    return file.basename.length > match[0].length;
                }
                
                return true;
                
            default:
                return false;
        }
    }

    async extractDateFromFile(file, dateExtraction) {
        const result = {
            startDate: null,
            endDate: null
        };

        // Extract start date
        if (dateExtraction.startDate) {
            const method = dateExtraction.startDate.method;
            
            if (method === 'property') {
                const propertyName = dateExtraction.startDate.propertyName;
                const cache = this.app.metadataCache.getFileCache(file);
                const dateStr = cache?.frontmatter?.[propertyName];
                
                if (dateStr) {
                    result.startDate = new Date(dateStr);
                }
            } else if (method === 'filename') {
                // Extract YYYY-MM-DD from filename
                const datePattern = /^(\d{4}-\d{2}-\d{2})/;
                const match = file.basename.match(datePattern);
                
                if (match) {
                    result.startDate = new Date(match[1]);
                }
            }
        }

        // Extract end date
        if (dateExtraction.endDate && dateExtraction.endDate.method !== 'none') {
            const method = dateExtraction.endDate.method;
            
            if (method === 'property') {
                const propertyName = dateExtraction.endDate.propertyName;
                const cache = this.app.metadataCache.getFileCache(file);
                const dateStr = cache?.frontmatter?.[propertyName];
                
                if (dateStr) {
                    result.endDate = new Date(dateStr);
                }
            } else if (method === 'filename') {
                // Extract date from end of filename (before extension)
                const datePattern = /(\d{4}-\d{2}-\d{2})$/;
                const match = file.basename.match(datePattern);
                
                if (match) {
                    result.endDate = new Date(match[1]);
                }
            }
        }

        return result;
    }

    processMultiDayEntries(notesMap, year) {
        const multiDayMap = new Map();
        
        notesMap.forEach((notes, dateKey) => {
            notes.forEach(noteInfo => {
                if (noteInfo.isMultiDay && noteInfo.endDate && !isNaN(noteInfo.endDate.getTime())) {
                    let currentDate = new Date(noteInfo.startDate);
                    const endDate = new Date(noteInfo.endDate);
                    
                    let monthCount = 0;
                    const maxMonths = 24;
                    
                    while (currentDate <= endDate && monthCount < maxMonths) {
                        const currentMonth = currentDate.getMonth();
                        const currentYear = currentDate.getFullYear();
                        const entryId = `${noteInfo.file.path}-${currentYear}-${currentMonth}`;
                        
                        if (!multiDayMap.has(entryId)) {
                            const segmentStartDay = currentDate.getDate();
                            const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
                            let segmentEndDay;
                            
                            if (endDate.getFullYear() === currentYear && endDate.getMonth() === currentMonth) {
                                segmentEndDay = endDate.getDate();
                            } else {
                                segmentEndDay = lastDayOfMonth;
                            }
                            
                            multiDayMap.set(entryId, {
                                file: noteInfo.file,
                                startDate: new Date(currentYear, currentMonth, segmentStartDay),
                                endDate: new Date(currentYear, currentMonth, segmentEndDay),
                                month: currentMonth,
                                year: currentYear
                            });
                        }
                        
                        currentDate = new Date(currentYear, currentMonth + 1, 1);
                        monthCount++;
                    }
                }
            });
        });
        
        return multiDayMap;
    }

    dateToKey(date) {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    }

    getDailyNoteFolder() {
        if (this.plugin.settings.dailyNoteFolderMode === 'obsidian') {
            const dailyNotesPlugin = this.app.internalPlugins?.plugins?.['daily-notes'];
            
            if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
                let folder = dailyNotesPlugin.instance?.options?.folder || '';
                folder = folder.replace(/^\/+|\/+$/g, '');
                return folder ? folder + '/' : '';
            }
            return '';
        } else {
            const folder = this.plugin.settings.dailyNoteCustomFolder;
            return folder ? folder + '/' : '';
        }
    }

    async findDailyNoteInFolder(filename, folderPath) {
        const files = this.app.vault.getMarkdownFiles();
        
        for (const file of files) {
            if (file.path.startsWith(folderPath) && file.name === filename) {
                return file;
            }
        }
        
        return null;
    }

    formatDateForDailyNote(date) {
        const format = this.plugin.settings.dailyNoteFormat;
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        
        return format
            .replace('YYYY', String(year))
            .replace('MM', month)
            .replace('DD', day);
    }

    async openOrCreateDailyNote(date) {
        const filename = this.formatDateForDailyNote(date);
        const folderPath = this.getDailyNoteFolder();
        
        const existingFile = await this.findDailyNoteInFolder(`${filename}.md`, folderPath);
        
        if (existingFile) {
            await this.app.workspace.getLeaf(false).openFile(existingFile);
        } else {
            const fullPath = `${folderPath}${filename}.md`;
            const newFile = await this.app.vault.create(fullPath, '');
            await this.app.workspace.getLeaf(false).openFile(newFile);
        }
    }

    async renderMonthRow(tbody, year, month, monthName, notesMap, multiDayEntries, maxDayCells) {
        const row = tbody.createEl('tr', { cls: 'month-row' });
        
        row.createEl('td', { text: monthName, cls: 'month-label' });

        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        const startingDayOfWeek = firstDay.getDay();

        const dayCells = [];

        const activeMultiDayEntries = [];
        
        multiDayEntries.forEach((entry) => {
            if (entry.month === month && entry.year === year) {
                activeMultiDayEntries.push(entry);
            }
        });

        const occupiedRows = [];
        const barPositions = new Map();
        
        activeMultiDayEntries.forEach((entry) => {
            const startDay = entry.startDate.getDate();
            const endDay = entry.endDate.getDate();
            
            const startCol = startingDayOfWeek + startDay - 1;
            const endCol = startingDayOfWeek + endDay - 1;
            const span = endCol - startCol + 1;
            
            if (span <= 0) return;
            
            let rowIndex = 0;
            while (occupiedRows.some(occupied => 
                occupied.row === rowIndex && 
                occupied.start < endCol + 1 && 
                occupied.end > startCol
            )) {
                rowIndex++;
            }
            
            occupiedRows.push({ row: rowIndex, start: startCol, end: endCol + 1 });
            barPositions.set(entry.file.path + '-' + entry.month, { rowIndex, startCol, endCol, span });
        });

        const maxBarRow = occupiedRows.length > 0 ? Math.max(...occupiedRows.map(o => o.row)) : -1;
        const topPadding = (maxBarRow + 1) * 16 + 18;

        for (let i = 0; i < startingDayOfWeek; i++) {
            const emptyCell = row.createEl('td', { cls: 'day-cell empty' });
            dayCells.push(emptyCell);
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, month, day);
            const dateKey = this.dateToKey(date);
            const dayCell = row.createEl('td', { cls: 'day-cell' });
            
            const dayIndex = startingDayOfWeek + day - 1;
            const barsAbove = occupiedRows.filter(o => o.start <= dayIndex && o.end > dayIndex).length;
            if (barsAbove > 0) {
                dayCell.style.paddingTop = `${topPadding}px`;
            }
            
            dayCells.push(dayCell);

            const dayNumber = dayCell.createEl('a', { 
                text: String(day).padStart(2, '0'), 
                cls: 'day-number day-number-link'
            });
            
            dayNumber.onclick = async (e) => {
                e.preventDefault();
                await this.openOrCreateDailyNote(date);
            };

            const notes = notesMap.get(dateKey);
            if (notes && notes.length > 0) {
                const notesContainer = dayCell.createDiv({ cls: 'day-notes' });
                
                const singleDayNotes = notes.filter(n => !n.isMultiDay);
                
                singleDayNotes.forEach(noteInfo => {
                    const noteLink = notesContainer.createEl('a', {
                        text: noteInfo.file.basename,
                        cls: 'note-link internal-link',
                        href: '#'
                    });
                    
                    noteLink.setAttr('data-href', noteInfo.file.path);
                    
                    noteLink.addEventListener('mouseover', (event) => {
                        this.app.workspace.trigger('hover-link', {
                            event,
                            source: VIEW_TYPE_CALENDAR,
                            hoverParent: this,
                            targetEl: noteLink,
                            linktext: noteInfo.file.path
                        });
                    });
                    
                    noteLink.onclick = (e) => {
                        e.preventDefault();
                        this.app.workspace.getLeaf(false).openFile(noteInfo.file);
                    };
                });
            }

            if (date.getTime() === today.getTime()) {
                dayCell.addClass('today');
            }
        }

        const cellsUsed = startingDayOfWeek + daysInMonth;
        const remainingCells = maxDayCells - cellsUsed;
        for (let i = 0; i < remainingCells; i++) {
            const emptyCell = row.createEl('td', { cls: 'day-cell empty' });
            dayCells.push(emptyCell);
        }

        // Create multi-day bars
        activeMultiDayEntries.forEach((entry) => {
            const pos = barPositions.get(entry.file.path + '-' + entry.month);
            if (!pos) return;
            
            const firstDayCell = dayCells[pos.startCol];
            if (firstDayCell && firstDayCell.classList.contains('day-cell')) {
                const multiDayBar = firstDayCell.createEl('div', {
                    cls: 'multi-day-bar'
                });
                
                multiDayBar.style.top = `${20 + (pos.rowIndex * 16)}px`;
                multiDayBar.dataset.span = pos.span.toString();
                
                const noteLink = multiDayBar.createEl('a', {
                    text: entry.file.basename,
                    cls: 'multi-day-link internal-link',
                    href: '#'
                });
                
                noteLink.setAttr('data-href', entry.file.path);
                
                noteLink.addEventListener('mouseover', (event) => {
                    this.app.workspace.trigger('hover-link', {
                        event,
                        source: VIEW_TYPE_CALENDAR,
                        hoverParent: this,
                        targetEl: noteLink,
                        linktext: entry.file.path
                    });
                });
                
                noteLink.onclick = (e) => {
                    e.preventDefault();
                    this.app.workspace.getLeaf(false).openFile(entry.file);
                };
                
                // Set width after DOM is rendered
                setTimeout(() => {
                    if (firstDayCell && firstDayCell.parentElement) {
                        const row = firstDayCell.parentElement;
                        const cells = Array.from(row.querySelectorAll('.day-cell'));
                        const startIndex = cells.indexOf(firstDayCell);
                        
                        if (startIndex >= 0 && startIndex + pos.span - 1 < cells.length) {
                            const lastCell = cells[startIndex + pos.span - 1];
                            
                            const firstCellRect = firstDayCell.getBoundingClientRect();
                            const lastCellRect = lastCell.getBoundingClientRect();
                            
                            const totalWidth = lastCellRect.right - firstCellRect.left - 6;
                            multiDayBar.style.width = `${totalWidth}px`;
                        }
                    }
                }, 0);
            }
        });

        row.createEl('td', { text: monthName, cls: 'month-label-right' });
    }

    async onClose() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
    }
}

class LinearCalendarPlugin extends obsidian.Plugin {
    async onload() {
        await this.loadSettings();

        this.registerView(
            VIEW_TYPE_CALENDAR,
            (leaf) => new LinearCalendarView(leaf, this)
        );

        this.addRibbonIcon('calendar', 'Open Linear Calendar', () => {
            this.activateView();
        });

        this.addCommand({
            id: 'open-linear-calendar',
            name: 'Open Linear Calendar',
            callback: () => {
                this.activateView();
            }
        });

        this.addSettingTab(new CalendarSettingTab(this.app, this));
    }

    async activateView() {
        const { workspace } = this.app;

        let leaf = null;
        const leaves = workspace.getLeavesOfType(VIEW_TYPE_CALENDAR);

        if (leaves.length > 0) {
            leaf = leaves[0];
        } else {
            leaf = workspace.getLeaf(false);
            await leaf.setViewState({ type: VIEW_TYPE_CALENDAR, active: true });
        }

        workspace.revealLeaf(leaf);
    }

    onunload() {
        this.app.workspace.detachLeavesOfType(VIEW_TYPE_CALENDAR);
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }
}

class CalendarSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display() {
        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'Linear Calendar Settings' });

        // Rules section
        this.renderRulesSection(containerEl);

        // Daily notes section
        this.renderDailyNotesSection(containerEl);
    }

    renderRulesSection(containerEl) {
        containerEl.createEl('h3', { text: 'Filter Rules' });
        
        const rulesContainer = containerEl.createDiv({ cls: 'rules-container' });
        
        // Render each rule
        this.plugin.settings.rules.forEach((rule, index) => {
            this.renderRule(rulesContainer, rule, index);
        });

        // Add new rule button
        new obsidian.Setting(containerEl)
            .addButton(button => button
                .setButtonText('+ Add New Rule')
                .onClick(async () => {
                    const newRule = {
                        id: `rule-${Date.now()}`,
                        name: `Rule ${this.plugin.settings.rules.length + 1}`,
                        description: '',
                        enabled: true,
                        filterGroups: [
                            {
                                logic: 'AND',
                                conditions: []
                            }
                        ],
                        dateExtraction: {
                            startDate: {
                                method: '',
                                propertyName: ''
                            },
                            endDate: {
                                method: '',
                                propertyName: ''
                            }
                        }
                    };
                    this.plugin.settings.rules.push(newRule);
                    await this.plugin.saveSettings();
                    this.display();
                }));
    }

    renderRule(container, rule, index) {
        const ruleEl = container.createDiv({ cls: 'rule-container' });
        ruleEl.style.cssText = 'border: 1px solid var(--background-modifier-border); padding: 15px; margin-bottom: 15px; border-radius: 5px;';

        // Rule header with checkbox, name, and delete button
        const headerEl = ruleEl.createDiv({ cls: 'rule-header' });
        headerEl.style.cssText = 'display: flex; align-items: flex-start; gap: 10px; margin-bottom: 10px;';

        // Enable toggle
        const toggleEl = headerEl.createEl('input', { type: 'checkbox' });
        toggleEl.checked = rule.enabled;
        toggleEl.style.cssText = 'margin-top: 8px; flex-shrink: 0;';
        toggleEl.onchange = async (e) => {
            rule.enabled = e.target.checked;
            await this.plugin.saveSettings();
        };

        // Name and description container
        const nameContainer = headerEl.createDiv();
        nameContainer.style.cssText = 'flex: 1; min-width: 0;';

        // Rule name
        const nameInput = nameContainer.createEl('input', { 
            type: 'text',
            value: rule.name,
            placeholder: 'Rule name'
        });
        nameInput.style.cssText = 'font-weight: 600; font-size: 1.1em; background: transparent; border: none; border-bottom: 1px solid transparent; width: 100%; box-sizing: border-box; margin-bottom: 5px;';
        nameInput.onfocus = () => {
            nameInput.style.borderBottom = '1px solid var(--interactive-accent)';
        };
        nameInput.onblur = async () => {
            nameInput.style.borderBottom = '1px solid transparent';
            rule.name = nameInput.value;
            await this.plugin.saveSettings();
        };

        // Rule description
        const descInput = nameContainer.createEl('textarea', { 
            value: rule.description || '',
            placeholder: 'Type a rule description...'
        });
        descInput.style.cssText = 'width: 100%; min-height: 40px; max-height: 100px; padding: 5px; box-sizing: border-box; resize: vertical; font-size: 0.9em; color: var(--text-muted); background: var(--background-secondary); border: 1px solid var(--background-modifier-border); border-radius: 3px;';
        descInput.onchange = async (e) => {
            rule.description = e.target.value;
            await this.plugin.saveSettings();
        };

        // Delete button
        const deleteBtn = headerEl.createEl('button', { text: 'Delete' });
        deleteBtn.style.cssText = 'background: var(--interactive-accent); color: var(--text-on-accent); border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; flex-shrink: 0; margin-top: 4px;';
        deleteBtn.onclick = async () => {
            this.plugin.settings.rules.splice(index, 1);
            await this.plugin.saveSettings();
            this.display();
        };

        // Filter conditions section with grey background
        const filterSection = ruleEl.createDiv();
        filterSection.createEl('h4', { text: 'Filter Conditions' }).style.marginTop = '10px';
        
        const filterContentBox = filterSection.createDiv();
        filterContentBox.style.cssText = 'padding: 10px; background: var(--background-secondary); border-radius: 3px;';
        
        rule.filterGroups.forEach((group, groupIndex) => {
            this.renderFilterGroup(filterContentBox, rule, group, groupIndex);
            
            // Add divider between groups (but not after the last one)
            if (groupIndex < rule.filterGroups.length - 1) {
                const divider = filterContentBox.createDiv();
                divider.style.cssText = 'height: 1px; background: var(--background-modifier-border); margin: 15px 0;';
            }
        });

        // Add group buttons
        const addGroupContainer = filterSection.createDiv();
        addGroupContainer.style.cssText = 'display: flex; gap: 10px; margin-top: 10px;';
        
        const addGroupBtn = addGroupContainer.createEl('button', { text: '+ Add filter group' });
        addGroupBtn.style.cssText = 'padding: 4px 8px; border-radius: 3px; cursor: pointer; background: transparent; border: none; box-shadow: none;';
        addGroupBtn.onclick = async () => {
            rule.filterGroups.push({
                logic: 'AND',
                conditions: []
            });
            await this.plugin.saveSettings();
            this.display();
        };

        // Date extraction section
        const dateSection = ruleEl.createDiv();
        dateSection.createEl('h4', { text: 'Date Extraction' }).style.marginTop = '15px';
        this.renderDateExtraction(dateSection, rule);
    }

    renderFilterGroup(container, rule, group, groupIndex) {
        const groupEl = container.createDiv();
        groupEl.style.cssText = 'padding: 10px 0; margin-bottom: 10px;';

        // Group header
        const groupHeader = groupEl.createDiv();
        groupHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; gap: 10px;';
        
        // Logic dropdown
        const logicSelect = groupHeader.createEl('select');
        logicSelect.style.cssText = 'padding: 4px 8px; font-weight: 600; background: transparent; border: none; cursor: pointer;';
        logicSelect.addClass('dropdown');
        
        const logicOptions = [
            { value: 'AND', label: 'All of the following are true' },
            { value: 'OR', label: 'Any of the following are true' },
            { value: 'NOT', label: 'None of the following are true' }
        ];
        
        logicOptions.forEach(opt => {
            const option = logicSelect.createEl('option', { 
                text: opt.label, 
                value: opt.value 
            });
            if (group.logic === opt.value) {
                option.selected = true;
            }
        });
        
        logicSelect.onchange = async (e) => {
            group.logic = e.target.value;
            await this.plugin.saveSettings();
        };

        const deleteGroupBtn = groupHeader.createEl('button', { text: 'ðŸ—‘' });
        deleteGroupBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 1.2em; opacity: 0.6;';
        deleteGroupBtn.onmouseover = () => { deleteGroupBtn.style.opacity = '1'; };
        deleteGroupBtn.onmouseout = () => { deleteGroupBtn.style.opacity = '0.6'; };
        deleteGroupBtn.onclick = async () => {
            rule.filterGroups.splice(groupIndex, 1);
            await this.plugin.saveSettings();
            this.display();
        };

        // Render conditions
        group.conditions.forEach((condition, condIndex) => {
            this.renderCondition(groupEl, rule, group, condition, condIndex);
        });

        // Add condition button
        const addCondBtn = groupEl.createEl('button', { text: '+ Add filter' });
        addCondBtn.style.cssText = 'padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-top: 5px; background: transparent; border: none; box-shadow: none;';
        addCondBtn.onclick = async () => {
            group.conditions.push({
                property: 'file.folder',
                operator: 'is',
                value: '',
                includeSubfolders: false
            });
            await this.plugin.saveSettings();
            this.display();
        };
    }

    renderCondition(container, rule, group, condition, condIndex) {
        const condEl = container.createDiv();
        condEl.style.cssText = 'display: flex; gap: 5px; align-items: center; margin-bottom: 5px; flex-wrap: wrap;';

        // Property selector
        const propertySelect = condEl.createEl('select');
        propertySelect.style.cssText = 'padding: 2px 5px;';
        propertySelect.addClass('dropdown');
        const properties = [
            { value: 'file.name', label: 'File name' },
            { value: 'file.basename', label: 'File basename' },
            { value: 'file.folder', label: 'Folder' },
            { value: 'file.path', label: 'File path' },
            { value: 'file.ext', label: 'Extension' },
            { value: 'custom', label: 'Custom property...' }
        ];
        properties.forEach(prop => {
            const option = propertySelect.createEl('option', { 
                text: prop.label, 
                value: prop.value 
            });
            if (condition.property === prop.value || 
                (prop.value === 'custom' && !properties.find(p => p.value === condition.property))) {
                option.selected = true;
            }
        });
        propertySelect.onchange = async (e) => {
            if (e.target.value === 'custom') {
                condition.property = '';
            } else {
                condition.property = e.target.value;
            }
            await this.plugin.saveSettings();
            this.display();
        };

        // If custom property, show text input
        if (propertySelect.value === 'custom' || !properties.find(p => p.value === condition.property)) {
            const customInput = condEl.createEl('input', { 
                type: 'text',
                placeholder: 'property name',
                value: condition.property
            });
            customInput.style.cssText = 'padding: 2px 5px; width: 100px;';
            customInput.onchange = async (e) => {
                condition.property = e.target.value;
                await this.plugin.saveSettings();
            };
        }

        // Operator selector
        const operatorSelect = condEl.createEl('select');
        operatorSelect.style.cssText = 'padding: 2px 5px;';
        operatorSelect.addClass('dropdown');
        const operators = [
            { value: 'is', label: 'is' },
            { value: 'isNot', label: 'is not' },
            { value: 'contains', label: 'contains' },
            { value: 'doesNotContain', label: 'does not contain' },
            { value: 'startsWith', label: 'starts with' },
            { value: 'endsWith', label: 'ends with' },
            { value: 'matches', label: 'matches regex' },
            { value: 'exists', label: 'exists' },
            { value: 'doesNotExist', label: 'does not exist' },
            { value: 'hasTag', label: 'has tag' },
            { value: 'matchesDatePattern', label: 'matches date pattern' }
        ];
        operators.forEach(op => {
            const option = operatorSelect.createEl('option', { 
                text: op.label, 
                value: op.value 
            });
            if (condition.operator === op.value) {
                option.selected = true;
            }
        });
        operatorSelect.onchange = async (e) => {
            condition.operator = e.target.value;
            await this.plugin.saveSettings();
            this.display();
        };

        // Value input (not needed for exists/doesNotExist)
        if (!['exists', 'doesNotExist'].includes(condition.operator)) {
            const valueInput = condEl.createEl('input', { 
                type: 'text',
                placeholder: 'value',
                value: condition.value || ''
            });
            valueInput.style.cssText = 'padding: 2px 5px; flex: 1; min-width: 100px;';
            valueInput.onchange = async (e) => {
                condition.value = e.target.value;
                await this.plugin.saveSettings();
            };
        }

        // Include subfolders option for folder property
        if (condition.property === 'file.folder' && condition.operator === 'is') {
            const subfolderLabel = condEl.createEl('label');
            subfolderLabel.style.cssText = 'display: flex; align-items: center; gap: 3px;';
            const subfolderCheckbox = subfolderLabel.createEl('input', { type: 'checkbox' });
            subfolderCheckbox.checked = condition.includeSubfolders || false;
            subfolderCheckbox.onchange = async (e) => {
                condition.includeSubfolders = e.target.checked;
                await this.plugin.saveSettings();
            };
            subfolderLabel.createEl('span', { text: 'Include subfolders' });
        }

        // Require additional text option for date pattern
        if (condition.operator === 'matchesDatePattern') {
            const requireTextLabel = condEl.createEl('label');
            requireTextLabel.style.cssText = 'display: flex; align-items: center; gap: 3px;';
            const requireTextCheckbox = requireTextLabel.createEl('input', { type: 'checkbox' });
            requireTextCheckbox.checked = condition.requireAdditionalText || false;
            requireTextCheckbox.onchange = async (e) => {
                condition.requireAdditionalText = e.target.checked;
                await this.plugin.saveSettings();
            };
            requireTextLabel.createEl('span', { text: 'Require text after date' });
        }

        // Delete condition button
        const deleteBtn = condEl.createEl('button', { text: 'Ã—' });
        deleteBtn.style.cssText = 'background: none; border: 1px solid var(--background-modifier-border); cursor: pointer; padding: 2px 8px; border-radius: 3px;';
        deleteBtn.onclick = async () => {
            group.conditions.splice(condIndex, 1);
            await this.plugin.saveSettings();
            this.display();
        };
    }

    renderDateExtraction(container, rule) {
        const extractionEl = container.createDiv();
        extractionEl.style.cssText = 'padding: 10px; background: var(--background-secondary); border-radius: 3px;';

        // Start date section
        const startDateContainer = extractionEl.createDiv();
        startDateContainer.style.cssText = 'margin-bottom: 15px;';
        
        const startLabel = startDateContainer.createEl('strong', { text: 'Start date:' });
        startLabel.style.cssText = 'display: block; margin-bottom: 5px;';
        
        const startSelectContainer = startDateContainer.createDiv();
        startSelectContainer.style.cssText = 'display: flex; gap: 10px; align-items: center; flex-wrap: wrap;';
        
        // Start date method dropdown
        const startMethodSelect = startSelectContainer.createEl('select');
        startMethodSelect.style.cssText = 'padding: 4px 8px; flex: 0 0 auto;';
        startMethodSelect.addClass('dropdown');
        
        const startOptions = [
            { value: '', label: '-- Select --' },
            { value: 'property', label: 'From property' },
            { value: 'filename', label: 'From filename (YYYY-MM-DD)' }
        ];
        
        startOptions.forEach(opt => {
            const option = startMethodSelect.createEl('option', { 
                text: opt.label, 
                value: opt.value 
            });
            if (rule.dateExtraction.startDate?.method === opt.value) {
                option.selected = true;
            }
        });
        
        // Property input container that we'll show/hide
        const startPropInputContainer = startSelectContainer.createDiv();
        startPropInputContainer.style.cssText = 'display: flex; flex: 1;';
        
        const startPropInput = startPropInputContainer.createEl('input', { 
            type: 'text',
            placeholder: 'Property name',
            value: rule.dateExtraction.startDate?.propertyName || ''
        });
        startPropInput.style.cssText = 'padding: 4px 8px; width: 100%;';
        
        // Show/hide property input based on selection
        if (rule.dateExtraction.startDate?.method !== 'property') {
            startPropInputContainer.style.display = 'none';
        }
        
        startMethodSelect.onchange = async (e) => {
            if (!rule.dateExtraction.startDate) rule.dateExtraction.startDate = {};
            rule.dateExtraction.startDate.method = e.target.value;
            
            // Show/hide property input
            if (e.target.value === 'property') {
                startPropInputContainer.style.display = 'flex';
            } else {
                startPropInputContainer.style.display = 'none';
            }
            
            await this.plugin.saveSettings();
        };
        
        startPropInput.onchange = async (e) => {
            if (!rule.dateExtraction.startDate) rule.dateExtraction.startDate = {};
            rule.dateExtraction.startDate.propertyName = e.target.value;
            await this.plugin.saveSettings();
        };

        // End date section
        const endDateContainer = extractionEl.createDiv();
        
        const endLabel = endDateContainer.createEl('strong', { text: 'End date (optional):' });
        endLabel.style.cssText = 'display: block; margin-bottom: 5px;';
        
        const endSelectContainer = endDateContainer.createDiv();
        endSelectContainer.style.cssText = 'display: flex; gap: 10px; align-items: center; flex-wrap: wrap;';
        
        // End date method dropdown
        const endMethodSelect = endSelectContainer.createEl('select');
        endMethodSelect.style.cssText = 'padding: 4px 8px; flex: 0 0 auto;';
        endMethodSelect.addClass('dropdown');
        
        const endOptions = [
            { value: '', label: '-- Select --' },
            { value: 'none', label: 'None (single day)' },
            { value: 'property', label: 'From property' },
            { value: 'filename', label: 'From filename (YYYY-MM-DD at end)' }
        ];
        
        endOptions.forEach(opt => {
            const option = endMethodSelect.createEl('option', { 
                text: opt.label, 
                value: opt.value 
            });
            const currentMethod = rule.dateExtraction.endDate?.method || '';
            if (currentMethod === opt.value) {
                option.selected = true;
            }
        });
        
        // Property input container that we'll show/hide
        const endPropInputContainer = endSelectContainer.createDiv();
        endPropInputContainer.style.cssText = 'display: flex; flex: 1;';
        
        const endPropInput = endPropInputContainer.createEl('input', { 
            type: 'text',
            placeholder: 'Property name',
            value: rule.dateExtraction.endDate?.propertyName || ''
        });
        endPropInput.style.cssText = 'padding: 4px 8px; width: 100%;';
        
        // Show/hide property input based on selection
        if (rule.dateExtraction.endDate?.method !== 'property') {
            endPropInputContainer.style.display = 'none';
        }
        
        endMethodSelect.onchange = async (e) => {
            if (!rule.dateExtraction.endDate) rule.dateExtraction.endDate = {};
            rule.dateExtraction.endDate.method = e.target.value;
            
            // Show/hide property input
            if (e.target.value === 'property') {
                endPropInputContainer.style.display = 'flex';
            } else {
                endPropInputContainer.style.display = 'none';
            }
            
            await this.plugin.saveSettings();
        };
        
        endPropInput.onchange = async (e) => {
            if (!rule.dateExtraction.endDate) rule.dateExtraction.endDate = {};
            rule.dateExtraction.endDate.propertyName = e.target.value;
            await this.plugin.saveSettings();
        };
    }

    renderDailyNotesSection(containerEl) {
        containerEl.createEl('h3', { text: 'Daily Notes' });

        new obsidian.Setting(containerEl)
            .setName('Daily note format')
            .setDesc('Format for daily note filenames (use YYYY for year, MM for month, DD for day)')
            .addText(text => text
                .setPlaceholder('YYYY-MM-DD')
                .setValue(this.plugin.settings.dailyNoteFormat)
                .onChange(async (value) => {
                    this.plugin.settings.dailyNoteFormat = value;
                    await this.plugin.saveSettings();
                }));

        new obsidian.Setting(containerEl)
            .setName('Daily notes folder mode')
            .setDesc('Choose where to look for and create daily notes')
            .addDropdown(dropdown => {
                dropdown.selectEl.addClass('dropdown');
                dropdown
                    .addOption('obsidian', 'Use native Daily Notes plugin\'s "New file location"')
                    .addOption('custom', 'Use custom folder')
                    .setValue(this.plugin.settings.dailyNoteFolderMode)
                    .onChange(async (value) => {
                        this.plugin.settings.dailyNoteFolderMode = value;
                        await this.plugin.saveSettings();
                        this.display();
                    });
            });

        if (this.plugin.settings.dailyNoteFolderMode === 'custom') {
            const setting = new obsidian.Setting(containerEl)
                .setName('Custom daily notes folder')
                .setDesc('Folder path for daily notes. Searches subfolders too.')
                .addText(text => {
                    text
                        .setPlaceholder('Daily Notes')
                        .setValue(this.plugin.settings.dailyNoteCustomFolder)
                        .onChange(async (value) => {
                            const cleaned = value.replace(/^\/+|\/+$/g, '');
                            this.plugin.settings.dailyNoteCustomFolder = cleaned;
                            await this.plugin.saveSettings();
                        });
                    
                    new FolderSuggest(this.app, text.inputEl);
                });
        }
    }
}

// Simple folder suggester
class FolderSuggest {
    constructor(app, inputEl) {
        this.app = app;
        this.inputEl = inputEl;
        this.suggestions = null;
        
        this.inputEl.addEventListener('input', () => this.updateSuggestions());
        this.inputEl.addEventListener('focus', () => this.updateSuggestions());
        this.inputEl.addEventListener('blur', () => {
            setTimeout(() => this.closeSuggestions(), 200);
        });
    }
    
    getAllFolders() {
        const folders = [];
        const recurse = (folder) => {
            if (folder.path) folders.push(folder.path);
            if (folder.children) {
                for (const child of folder.children) {
                    if (child instanceof obsidian.TFolder) {
                        recurse(child);
                    }
                }
            }
        };
        recurse(this.app.vault.getRoot());
        return folders;
    }
    
    updateSuggestions() {
        const query = this.inputEl.value.toLowerCase();
        const allFolders = this.getAllFolders();
        const matches = allFolders
            .filter(folder => folder.toLowerCase().includes(query))
            .slice(0, 10);
        
        this.showSuggestions(matches);
    }
    
    showSuggestions(folders) {
        this.closeSuggestions();
        
        if (folders.length === 0) return;
        
        this.suggestions = document.createElement('div');
        this.suggestions.className = 'suggestion-container';
        this.suggestions.style.cssText = 'position: absolute; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 4px; padding: 4px; z-index: 1000; max-height: 200px; overflow-y: auto;';
        
        folders.forEach(folder => {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            item.textContent = folder;
            item.style.cssText = 'padding: 4px 8px; cursor: pointer; border-radius: 3px;';
            item.addEventListener('mouseenter', () => {
                item.style.background = 'var(--background-modifier-hover)';
            });
            item.addEventListener('mouseleave', () => {
                item.style.background = '';
            });
            item.addEventListener('click', () => {
                this.inputEl.value = folder;
                this.inputEl.dispatchEvent(new Event('input'));
                this.closeSuggestions();
            });
            this.suggestions.appendChild(item);
        });
        
        const rect = this.inputEl.getBoundingClientRect();
        this.suggestions.style.top = (rect.bottom + 2) + 'px';
        this.suggestions.style.left = rect.left + 'px';
        this.suggestions.style.width = rect.width + 'px';
        
        document.body.appendChild(this.suggestions);
    }
    
    closeSuggestions() {
        if (this.suggestions) {
            this.suggestions.remove();
            this.suggestions = null;
        }
    }
}

module.exports = LinearCalendarPlugin;
